@inject IJSRuntime JS
@inject IStringLocalizer<SharedResource> L

@if (_isActive && _currentStep < _steps.Count)
{
    <!-- Overlay -->
    <div class="fixed inset-0 z-[9998] bg-black/50 backdrop-blur-sm transition-opacity duration-300"
         @onclick="SkipTour"></div>
    
    <!-- Spotlight on target element -->
    <div id="tour-spotlight" 
         class="fixed z-[9999] rounded-xl ring-4 ring-primary-500 ring-offset-4 ring-offset-transparent shadow-2xl shadow-primary-500/50 transition-all duration-500 pointer-events-none"
         style="@_spotlightStyle">
    </div>

    <!-- Tooltip -->
    <div class="fixed z-[10000] w-80 animate-in slide-in-from-bottom-4 duration-300"
         style="@_tooltipStyle">
        <div class="bg-white dark:bg-gray-800 rounded-2xl shadow-2xl border border-gray-200 dark:border-gray-700 overflow-hidden">
            <!-- Header -->
            <div class="bg-gradient-to-r from-primary-500 to-accent-500 px-4 py-3">
                <div class="flex items-center justify-between">
                    <span class="text-white/80 text-sm font-medium">
                        @L["TourStep"] @(_currentStep + 1) / @_steps.Count
                    </span>
                    <button @onclick="SkipTour" 
                            class="text-white/60 hover:text-white transition-colors">
                        <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/>
                        </svg>
                    </button>
                </div>
            </div>
            
            <!-- Content -->
            <div class="p-4">
                <h3 class="text-lg font-bold text-gray-900 dark:text-white mb-2">
                    @CurrentStep.Title
                </h3>
                <p class="text-gray-600 dark:text-gray-300 text-sm leading-relaxed">
                    @CurrentStep.Description
                </p>
            </div>
            
            <!-- Footer -->
            <div class="px-4 pb-4 flex items-center justify-between">
                <!-- Progress dots -->
                <div class="flex gap-1.5">
                    @for (int i = 0; i < _steps.Count; i++)
                    {
                        var idx = i;
                        <button @onclick="() => GoToStep(idx)"
                                class="w-2 h-2 rounded-full transition-all duration-300 @(i == _currentStep ? "bg-primary-500 w-6" : "bg-gray-300 dark:bg-gray-600 hover:bg-primary-300")">
                        </button>
                    }
                </div>
                
                <!-- Navigation -->
                <div class="flex gap-2">
                    @if (_currentStep > 0)
                    {
                        <button @onclick="PreviousStep"
                                class="px-3 py-1.5 text-sm text-gray-600 dark:text-gray-300 hover:text-gray-900 dark:hover:text-white transition-colors">
                            @L["Previous"]
                        </button>
                    }
                    
                    @if (_currentStep < _steps.Count - 1)
                    {
                        <button @onclick="NextStep"
                                class="px-4 py-1.5 text-sm bg-primary-500 text-white rounded-lg hover:bg-primary-600 transition-colors font-medium">
                            @L["Next"]
                        </button>
                    }
                    else
                    {
                        <button @onclick="CompleteTour"
                                class="px-4 py-1.5 text-sm bg-gradient-to-r from-primary-500 to-accent-500 text-white rounded-lg hover:opacity-90 transition-opacity font-medium">
                            @L["StartUsing"]
                        </button>
                    }
                </div>
            </div>
        </div>
        
        <!-- Arrow pointer -->
        <div class="absolute w-4 h-4 bg-white dark:bg-gray-800 border-l border-t border-gray-200 dark:border-gray-700 transform rotate-45"
             style="@_arrowStyle"></div>
    </div>
}

@code {
    [Parameter] public List<TourStep> Steps { get; set; } = new();
    [Parameter] public EventCallback OnComplete { get; set; }
    [Parameter] public EventCallback OnSkip { get; set; }
    [Parameter] public string TourId { get; set; } = "default";

    private List<TourStep> _steps = new();
    private int _currentStep = 0;
    private bool _isActive = false;
    private bool _initialized = false;
    private string _spotlightStyle = "";
    private string _tooltipStyle = "";
    private string _arrowStyle = "";

    private TourStep CurrentStep => _steps.Count > _currentStep ? _steps[_currentStep] : new TourStep();

    protected override void OnParametersSet()
    {
        _steps = Steps;
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        // Wait for steps to be populated (they're set after data loads)
        if (_steps.Any() && !_initialized)
        {
            _initialized = true;
            try
            {
                // Check if tour was already completed - JS is safe here
                var completed = await JS.InvokeAsync<string>("localStorage.getItem", $"tour_completed_{TourId}");
                if (string.IsNullOrEmpty(completed))
                {
                    await StartTour();
                }
            }
            catch
            {
                // JS interop failed, skip tour
            }
        }
    }

    public async Task StartTour()
    {
        if (!_steps.Any()) return;
        
        _currentStep = 0;
        _isActive = true;
        
        // Wait for DOM to be fully rendered before calculating positions
        await Task.Delay(500);
        await UpdatePosition();
        StateHasChanged();
    }

    private async Task NextStep()
    {
        if (_currentStep < _steps.Count - 1)
        {
            _currentStep++;
            await UpdatePosition();
        }
    }

    private async Task PreviousStep()
    {
        if (_currentStep > 0)
        {
            _currentStep--;
            await UpdatePosition();
        }
    }

    private async Task GoToStep(int step)
    {
        if (step >= 0 && step < _steps.Count)
        {
            _currentStep = step;
            await UpdatePosition();
        }
    }

    private async Task UpdatePosition()
    {
        var step = CurrentStep;
        if (string.IsNullOrEmpty(step.TargetSelector)) return;

        try
        {
            // First scroll the element into view
            await JS.InvokeVoidAsync("scrollTourElementIntoView", step.TargetSelector);
            
            // Wait for scroll animation to complete
            await Task.Delay(400);
            
            // Now get the position (after scroll)
            ElementRect? rect = null;
            for (int retry = 0; retry < 5; retry++)
            {
                rect = await JS.InvokeAsync<ElementRect>("getTourElementRect", step.TargetSelector);
                if (rect != null && rect.Width > 0 && rect.Height > 0)
                    break;
                await Task.Delay(150);
            }
            
            if (rect != null && rect.Width > 0 && rect.Height > 0)
            {
                // Spotlight position - use viewport coordinates
                var padding = 12;
                _spotlightStyle = $"top: {rect.Top - padding}px; left: {rect.Left - padding}px; width: {rect.Width + padding * 2}px; height: {rect.Height + padding * 2}px;";

                // Tooltip position based on placement
                var tooltipOffset = 20;
                var tooltipWidth = 320; // w-80 = 20rem = 320px
                var tooltipHeight = 200; // approximate
                
                // Ensure tooltip stays within viewport
                var viewportWidth = 1200; // fallback
                var viewportHeight = 800; // fallback
                
                double tooltipTop, tooltipLeft;
                
                switch (step.Placement)
                {
                    case TooltipPlacement.Bottom:
                        tooltipTop = rect.Bottom + tooltipOffset;
                        tooltipLeft = Math.Max(16, Math.Min(rect.Left + rect.Width / 2 - tooltipWidth / 2, viewportWidth - tooltipWidth - 16));
                        _tooltipStyle = $"top: {tooltipTop}px; left: {tooltipLeft}px;";
                        _arrowStyle = "top: -8px; left: 50%; margin-left: -8px;";
                        break;
                    case TooltipPlacement.Top:
                        tooltipTop = rect.Top - tooltipOffset - tooltipHeight;
                        tooltipLeft = Math.Max(16, Math.Min(rect.Left + rect.Width / 2 - tooltipWidth / 2, viewportWidth - tooltipWidth - 16));
                        _tooltipStyle = $"top: {Math.Max(16, tooltipTop)}px; left: {tooltipLeft}px;";
                        _arrowStyle = "bottom: -8px; left: 50%; margin-left: -8px; transform: rotate(225deg);";
                        break;
                    case TooltipPlacement.Left:
                        tooltipTop = rect.Top + rect.Height / 2 - 100;
                        tooltipLeft = rect.Left - tooltipWidth - tooltipOffset;
                        _tooltipStyle = $"top: {Math.Max(16, tooltipTop)}px; left: {Math.Max(16, tooltipLeft)}px;";
                        _arrowStyle = "right: -8px; top: 50%; margin-top: -8px; transform: rotate(135deg);";
                        break;
                    case TooltipPlacement.Right:
                    default:
                        tooltipTop = rect.Top + rect.Height / 2 - 100;
                        tooltipLeft = rect.Right + tooltipOffset;
                        _tooltipStyle = $"top: {Math.Max(16, tooltipTop)}px; left: {tooltipLeft}px;";
                        _arrowStyle = "left: -8px; top: 50%; margin-top: -8px; transform: rotate(-45deg);";
                        break;
                }
            }
            else
            {
                // Element not found after retries, skip to next step
                if (_currentStep < _steps.Count - 1)
                    await NextStep();
                else
                    await CompleteTour();
                return;
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Tour error: {ex.Message}");
            // Element not found, skip to next step or end tour
            if (_currentStep < _steps.Count - 1)
                await NextStep();
            else
                await CompleteTour();
        }
        
        StateHasChanged();
    }

    private async Task CompleteTour()
    {
        _isActive = false;
        await JS.InvokeVoidAsync("localStorage.setItem", $"tour_completed_{TourId}", DateTime.UtcNow.ToString("o"));
        await OnComplete.InvokeAsync();
        StateHasChanged();
    }

    private async Task SkipTour()
    {
        _isActive = false;
        await JS.InvokeVoidAsync("localStorage.setItem", $"tour_completed_{TourId}", DateTime.UtcNow.ToString("o"));
        await OnSkip.InvokeAsync();
        StateHasChanged();
    }

    public class TourStep
    {
        public string Title { get; set; } = "";
        public string Description { get; set; } = "";
        public string TargetSelector { get; set; } = "";
        public TooltipPlacement Placement { get; set; } = TooltipPlacement.Bottom;
    }

    public enum TooltipPlacement
    {
        Top,
        Bottom,
        Left,
        Right
    }

    private class ElementRect
    {
        public double Top { get; set; }
        public double Left { get; set; }
        public double Right { get; set; }
        public double Bottom { get; set; }
        public double Width { get; set; }
        public double Height { get; set; }
    }
}

