@using System.Globalization
@inject IJSRuntime JS
@inject IStringLocalizer<SharedResource> L
@inject ILogger<GuidedTour> Logger

@if (_isActive && _currentStep < _steps.Count)
{
    <!-- Overlay -->
    <div class="fixed inset-0 z-[9998] bg-black/50 backdrop-blur-sm transition-opacity duration-300"
         @onclick="SkipTour"></div>
    
    <!-- Spotlight on target element -->
    <div id="tour-spotlight" 
         class="fixed z-[9999] rounded-xl ring-4 ring-primary-500 ring-offset-4 ring-offset-transparent shadow-2xl shadow-primary-500/50 transition-all duration-500 pointer-events-none"
         style="@_spotlightStyle">
    </div>

    <!-- Tooltip -->
    <div class="fixed z-[10000] w-80 animate-in slide-in-from-bottom-4 duration-300"
         style="@_tooltipStyle">
        <div class="bg-white dark:bg-gray-800 rounded-2xl shadow-2xl border border-gray-200 dark:border-gray-700 overflow-hidden">
            <!-- Header -->
            <div class="bg-gradient-to-r from-primary-500 to-accent-500 px-4 py-3">
                <div class="flex items-center justify-between">
                    <span class="text-white/80 text-sm font-medium">
                        @L["TourStep"] @(_currentStep + 1) / @_steps.Count
                    </span>
                    <button @onclick="SkipTour" 
                            class="text-white/60 hover:text-white transition-colors">
                        <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/>
                        </svg>
                    </button>
                </div>
            </div>
            
            <!-- Content -->
            <div class="p-4">
                <h3 class="text-lg font-bold text-gray-900 dark:text-white mb-2">
                    @CurrentStep.Title
                </h3>
                <p class="text-gray-600 dark:text-gray-300 text-sm leading-relaxed">
                    @CurrentStep.Description
                </p>
            </div>
            
            <!-- Footer -->
            <div class="px-4 pb-4 flex items-center justify-between">
                <!-- Progress dots -->
                <div class="flex gap-1.5">
                    @for (int i = 0; i < _steps.Count; i++)
                    {
                        var idx = i;
                        <button @onclick="() => GoToStep(idx)"
                                class="w-2 h-2 rounded-full transition-all duration-300 @(i == _currentStep ? "bg-primary-500 w-6" : "bg-gray-300 dark:bg-gray-600 hover:bg-primary-300")">
                        </button>
                    }
                </div>
                
                <!-- Navigation -->
                <div class="flex gap-2">
                    @if (_currentStep > 0)
                    {
                        <button @onclick="PreviousStep"
                                class="px-3 py-1.5 text-sm text-gray-600 dark:text-gray-300 hover:text-gray-900 dark:hover:text-white transition-colors">
                            @L["Previous"]
                        </button>
                    }
                    
                    @if (_currentStep < _steps.Count - 1)
                    {
                        <button @onclick="NextStep"
                                class="px-4 py-1.5 text-sm bg-primary-500 text-white rounded-lg hover:bg-primary-600 transition-colors font-medium">
                            @L["Next"]
                        </button>
                    }
                    else
                    {
                        <button @onclick="CompleteTour"
                                class="px-4 py-1.5 text-sm bg-gradient-to-r from-primary-500 to-accent-500 text-white rounded-lg hover:opacity-90 transition-opacity font-medium">
                            @L["StartUsing"]
                        </button>
                    }
                </div>
            </div>
        </div>
        
        <!-- Arrow pointer (CSS triangle) -->
        <div class="absolute" style="@_arrowStyle"></div>
    </div>
}

@code {
    [Parameter] public List<TourStep> Steps { get; set; } = new();
    [Parameter] public EventCallback OnComplete { get; set; }
    [Parameter] public EventCallback OnSkip { get; set; }
    [Parameter] public string TourId { get; set; } = "default";

    private List<TourStep> _steps = new();
    private int _currentStep = 0;
    private bool _isActive = false;
    private bool _initialized = false;
    private string _spotlightStyle = "";
    private string _tooltipStyle = "";
    private string _arrowStyle = "";

    private TourStep CurrentStep => _steps.Count > _currentStep ? _steps[_currentStep] : new TourStep();

    protected override void OnParametersSet()
    {
        _steps = Steps;
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        // Wait for steps to be populated (they're set after data loads)
        if (_steps.Any() && !_initialized)
        {
            _initialized = true;
            try
            {
                // Check if tour was already completed - JS is safe here
                var completed = await JS.InvokeAsync<string>("localStorage.getItem", $"tour_completed_{TourId}");
                if (string.IsNullOrEmpty(completed))
                {
                    await StartTour();
                }
            }
            catch
            {
                // JS interop failed, skip tour
            }
        }
    }

    public async Task StartTour()
    {
        if (!_steps.Any()) return;
        
        _currentStep = 0;
        _isActive = true;
        
        // Wait for DOM to be fully rendered before calculating positions
        await Task.Delay(500);
        await UpdatePosition();
        StateHasChanged();
    }

    private async Task NextStep()
    {
        if (_currentStep < _steps.Count - 1)
        {
            _currentStep++;
            await UpdatePosition();
        }
    }

    private async Task PreviousStep()
    {
        if (_currentStep > 0)
        {
            _currentStep--;
            await UpdatePosition();
        }
    }

    private async Task GoToStep(int step)
    {
        if (step >= 0 && step < _steps.Count)
        {
            _currentStep = step;
            await UpdatePosition();
        }
    }

    private async Task UpdatePosition()
    {
        var step = CurrentStep;
        if (string.IsNullOrEmpty(step.TargetSelector)) return;

        try
        {
            // First scroll the element into view
            await JS.InvokeVoidAsync("scrollTourElementIntoView", step.TargetSelector);
            
            // Wait for scroll animation to complete
            await Task.Delay(400);
            
            // Now get the position (after scroll)
            ElementRect? rect = null;
            for (int retry = 0; retry < 5; retry++)
            {
                rect = await JS.InvokeAsync<ElementRect>("getTourElementRect", step.TargetSelector);
                if (rect != null && rect.Width > 0 && rect.Height > 0)
                    break;
                await Task.Delay(150);
            }
            
            if (rect != null && rect.Width > 0 && rect.Height > 0)
            {
                // Spotlight position - use viewport coordinates
                // IMPORTANT: Use InvariantCulture for CSS values (decimal point, not comma)
                var padding = 12;
                var spotTop = (rect.Top - padding).ToString(CultureInfo.InvariantCulture);
                var spotLeft = (rect.Left - padding).ToString(CultureInfo.InvariantCulture);
                var spotWidth = (rect.Width + padding * 2).ToString(CultureInfo.InvariantCulture);
                var spotHeight = (rect.Height + padding * 2).ToString(CultureInfo.InvariantCulture);
                _spotlightStyle = $"top: {spotTop}px; left: {spotLeft}px; width: {spotWidth}px; height: {spotHeight}px;";

                // Tooltip position based on placement
                var tooltipOffset = 20;
                var tooltipWidth = 320; // w-80 = 20rem = 320px
                var tooltipHeight = 200; // approximate
                
                // Use actual viewport dimensions from JS
                var viewportWidth = rect.ViewportWidth > 0 ? rect.ViewportWidth : 1200;
                var viewportHeight = rect.ViewportHeight > 0 ? rect.ViewportHeight : 800;
                
                double tooltipTop = 0, tooltipLeft = 0;
                
                // Calculate tooltip position with fallback for edge cases
                var preferredPlacement = step.Placement;
                
                // Check if preferred placement would put tooltip off-screen and adjust
                // Arrow styles using CSS triangles (borders)
                // Dark mode: #1f2937 (gray-800), Light mode: white
                var arrowColor = "#1f2937"; // dark mode default
                
                switch (preferredPlacement)
                {
                    case TooltipPlacement.Bottom:
                        tooltipTop = rect.Bottom + tooltipOffset;
                        if (tooltipTop + tooltipHeight > viewportHeight - 16)
                        {
                            tooltipTop = rect.Top - tooltipOffset - tooltipHeight;
                            if (tooltipTop < 16) tooltipTop = 16;
                            // Arrow pointing DOWN (at bottom of tooltip)
                            _arrowStyle = $"bottom: -10px; left: 50%; margin-left: -10px; width: 0; height: 0; border-left: 10px solid transparent; border-right: 10px solid transparent; border-top: 10px solid {arrowColor};";
                        }
                        else
                        {
                            // Arrow pointing UP (at top of tooltip)
                            _arrowStyle = $"top: -10px; left: 50%; margin-left: -10px; width: 0; height: 0; border-left: 10px solid transparent; border-right: 10px solid transparent; border-bottom: 10px solid {arrowColor};";
                        }
                        tooltipLeft = Math.Max(16, Math.Min(rect.Left + rect.Width / 2 - tooltipWidth / 2, viewportWidth - tooltipWidth - 16));
                        break;
                        
                    case TooltipPlacement.Top:
                        tooltipTop = rect.Top - tooltipOffset - tooltipHeight;
                        if (tooltipTop < 16)
                        {
                            tooltipTop = rect.Bottom + tooltipOffset;
                            // Arrow pointing UP
                            _arrowStyle = $"top: -10px; left: 50%; margin-left: -10px; width: 0; height: 0; border-left: 10px solid transparent; border-right: 10px solid transparent; border-bottom: 10px solid {arrowColor};";
                        }
                        else
                        {
                            // Arrow pointing DOWN
                            _arrowStyle = $"bottom: -10px; left: 50%; margin-left: -10px; width: 0; height: 0; border-left: 10px solid transparent; border-right: 10px solid transparent; border-top: 10px solid {arrowColor};";
                        }
                        tooltipLeft = Math.Max(16, Math.Min(rect.Left + rect.Width / 2 - tooltipWidth / 2, viewportWidth - tooltipWidth - 16));
                        break;
                        
                    case TooltipPlacement.Left:
                        tooltipLeft = rect.Left - tooltipWidth - tooltipOffset;
                        if (tooltipLeft < 16)
                        {
                            tooltipLeft = rect.Right + tooltipOffset;
                            if (tooltipLeft + tooltipWidth > viewportWidth - 16)
                            {
                                tooltipTop = rect.Bottom + tooltipOffset;
                                tooltipLeft = Math.Max(16, Math.Min(rect.Left + rect.Width / 2 - tooltipWidth / 2, viewportWidth - tooltipWidth - 16));
                                _arrowStyle = $"top: -10px; left: 50%; margin-left: -10px; width: 0; height: 0; border-left: 10px solid transparent; border-right: 10px solid transparent; border-bottom: 10px solid {arrowColor};";
                            }
                            else
                            {
                                tooltipTop = Math.Max(16, Math.Min(rect.Top + rect.Height / 2 - 100, viewportHeight - tooltipHeight - 16));
                                // Arrow pointing LEFT (on left side of tooltip)
                                _arrowStyle = $"left: -10px; top: 50%; margin-top: -10px; width: 0; height: 0; border-top: 10px solid transparent; border-bottom: 10px solid transparent; border-right: 10px solid {arrowColor};";
                            }
                        }
                        else
                        {
                            tooltipTop = Math.Max(16, Math.Min(rect.Top + rect.Height / 2 - 100, viewportHeight - tooltipHeight - 16));
                            // Arrow pointing RIGHT (on right side of tooltip)
                            _arrowStyle = $"right: -10px; top: 50%; margin-top: -10px; width: 0; height: 0; border-top: 10px solid transparent; border-bottom: 10px solid transparent; border-left: 10px solid {arrowColor};";
                        }
                        break;
                        
                    case TooltipPlacement.Right:
                    default:
                        tooltipLeft = rect.Right + tooltipOffset;
                        if (tooltipLeft + tooltipWidth > viewportWidth - 16)
                        {
                            tooltipLeft = rect.Left - tooltipWidth - tooltipOffset;
                            if (tooltipLeft < 16)
                            {
                                tooltipTop = rect.Bottom + tooltipOffset;
                                tooltipLeft = Math.Max(16, Math.Min(rect.Left + rect.Width / 2 - tooltipWidth / 2, viewportWidth - tooltipWidth - 16));
                                _arrowStyle = $"top: -10px; left: 50%; margin-left: -10px; width: 0; height: 0; border-left: 10px solid transparent; border-right: 10px solid transparent; border-bottom: 10px solid {arrowColor};";
                            }
                            else
                            {
                                tooltipTop = Math.Max(16, Math.Min(rect.Top + rect.Height / 2 - 100, viewportHeight - tooltipHeight - 16));
                                // Arrow pointing RIGHT
                                _arrowStyle = $"right: -10px; top: 50%; margin-top: -10px; width: 0; height: 0; border-top: 10px solid transparent; border-bottom: 10px solid transparent; border-left: 10px solid {arrowColor};";
                            }
                        }
                        else
                        {
                            tooltipTop = Math.Max(16, Math.Min(rect.Top + rect.Height / 2 - 100, viewportHeight - tooltipHeight - 16));
                            // Arrow pointing LEFT
                            _arrowStyle = $"left: -10px; top: 50%; margin-top: -10px; width: 0; height: 0; border-top: 10px solid transparent; border-bottom: 10px solid transparent; border-right: 10px solid {arrowColor};";
                        }
                        break;
                }
                
                // Format with InvariantCulture for CSS
                var ttTop = tooltipTop.ToString(CultureInfo.InvariantCulture);
                var ttLeft = tooltipLeft.ToString(CultureInfo.InvariantCulture);
                _tooltipStyle = $"top: {ttTop}px; left: {ttLeft}px;";
            }
            else
            {
                // Element not found after retries, skip to next step
                if (_currentStep < _steps.Count - 1)
                    await NextStep();
                else
                    await CompleteTour();
                return;
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Tour error: {ex.Message}");
            // Element not found, skip to next step or end tour
            if (_currentStep < _steps.Count - 1)
                await NextStep();
            else
                await CompleteTour();
        }
        
        StateHasChanged();
    }

    private async Task CompleteTour()
    {
        _isActive = false;
        await JS.InvokeVoidAsync("localStorage.setItem", $"tour_completed_{TourId}", DateTime.UtcNow.ToString("o"));
        await OnComplete.InvokeAsync();
        StateHasChanged();
    }

    private async Task SkipTour()
    {
        _isActive = false;
        await JS.InvokeVoidAsync("localStorage.setItem", $"tour_completed_{TourId}", DateTime.UtcNow.ToString("o"));
        await OnSkip.InvokeAsync();
        StateHasChanged();
    }

    public class TourStep
    {
        public string Title { get; set; } = "";
        public string Description { get; set; } = "";
        public string TargetSelector { get; set; } = "";
        public TooltipPlacement Placement { get; set; } = TooltipPlacement.Bottom;
    }

    public enum TooltipPlacement
    {
        Top,
        Bottom,
        Left,
        Right
    }

    private class ElementRect
    {
        public double Top { get; set; }
        public double Left { get; set; }
        public double Right { get; set; }
        public double Bottom { get; set; }
        public double Width { get; set; }
        public double Height { get; set; }
        public double ViewportWidth { get; set; } = 1200;
        public double ViewportHeight { get; set; } = 800;
    }
}

